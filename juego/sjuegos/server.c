/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "gestionJuego.h"
#include "registroJuego.h"
#include <time.h>
#include <stdbool.h>

int contador = 0;

int numeroAleatorio(int min, int max)
{
	int num;
	srand(time(NULL));
	num = min + rand() % (max-min);
	return num;
}

//Estructura para guardar los datos del juego
struct data_config
{
    int id_partida;
    int rol;
    int repetirColor;
    int estado;
};

//Estructura para guardar los colores
struct data_color
{
	char color1[JMAXDAT];
    char color2[JMAXDAT];
    char color3[JMAXDAT];
    char color4[JMAXDAT];
    char color5[JMAXDAT];
    int generacion;
};

//Estructura de colores para adivinar
struct solucion_color
{
	char color1[JMAXDAT];
    char color2[JMAXDAT];
    char color3[JMAXDAT];
    char color4[JMAXDAT];
    char color5[JMAXDAT];
};


//Estructura para guardar las espigas
struct data_espiga
{
	char espiga1[JMAXDAT];
	char espiga2[JMAXDAT];
	char espiga3[JMAXDAT];
	char espiga4[JMAXDAT];
	char espiga5[JMAXDAT];
	int generacion;
};


// Estructura para guardar los datos del juego
struct data_fin_juego{
    int id_partida;
    int id_ganador;
    int puntaje1;
    int puntaje2;
};



struct data_config config = {.id_partida = 0, .estado = 0};
struct data_color color;
struct data_espiga espiga;
struct solucion_color solucion;
struct data_fin_juego final;
int generacionEspigas = 0;
int generacionColores = 0;
int codigo;
int id_jugador1;
int id_jugador2;
int partidaJ1 = 0;
int primeraVez = 0;




int *
iniciarjuego_1_svc(int *argp, struct svc_req *rqstp)
{
	static int  result;

	// contar los usuarios que llegan
	// si son 2, iniciar el juego
	printf("\n*** Juego Iniciado ***\n");
	contador = contador + 1;
	partidaJ1 = 1;

	if (contador == 1)
	{		
		//Guardar el id del jugador 1
		printf("\n*** Jugador 1: %d ***\n", *argp);
		id_jugador1 = *argp;		
	}else
	{
		//Verificar que no sea el mismo jugador
		if (*argp == id_jugador1)
		{
			printf("\n*** Jugador 1 y Jugador 2 son el mismo ***\n");
			result =  -1; 
			return &result;
		}
		//Guardar el id del jugador 2
		printf("*** Jugador 2: %d ***\n", *argp);
		id_jugador2 = *argp;

		//Guardar el id del juego
		codigo = numeroAleatorio(1, 1000);

		//Reiniciar el contador para el siguiente juego
		contador = 0;		
	}
	result = codigo;
	return &result;
}

void *
enviarconfiguracion_1_svc(config_juego *argp, struct svc_req *rqstp)
{
	static char * result;
	int codigo;
	printf("\n*** Configuracion Recibida ***\n");

	config.id_partida = codigo;
	config.rol = argp->rol;
	config.repetirColor = argp->repetirColor;
	config.estado = argp->estado;

	return (void *) &result;
}

config_juego *
configuracion_1_svc(void *argp, struct svc_req *rqstp)
{
	static config_juego  result;

	printf("\n*** Enviar configuracion al cliente ***\n");

	result.id_partida = config.id_partida;
	result.rol =  config.rol;
	result.repetirColor = config.repetirColor;
	result.estado = config.estado;

	return &result;
}

bool_t *
enviarcolores_1_svc(info_color *argp, struct svc_req *rqstp)
{
	static bool_t  result;

	printf("*** Enviar colores***\n");

	// si es primera vez que entra a este metodo es la solucion
	// Que el jugador 2 tiene que adivinar los guardamos en la estructura solucion
	if (primeraVez == 0)
	{
		strcpy(solucion.color1, argp->color1);
		strcpy(solucion.color2, argp->color2);
		strcpy(solucion.color3, argp->color3);
		strcpy(solucion.color4, argp->color4);
		strcpy(solucion.color5, argp->color5);
		color.generacion = generacionColores;
		primeraVez = 1;
	}else{
		generacionColores += 1;
		color.generacion = generacionColores;
		strcpy(color.color1, argp->color1);
		strcpy(color.color2, argp->color2);
		strcpy(color.color3, argp->color3);
		strcpy(color.color4, argp->color4);
		strcpy(color.color5, argp->color5);

		//Mirar si el jugador 2 adivino los colores
		if (strcmp(solucion.color1, argp->color1) == 0 && strcmp(solucion.color2, argp->color2) == 0 && strcmp(solucion.color3, argp->color3) == 0 && strcmp(solucion.color4, argp->color4) == 0 && strcmp(solucion.color5, argp->color5) == 0)
		{
			printf("*** Jugador 2 adivino los colores ***\n");
			config.estado = 2;
			final.puntaje1 += generacionColores;
			partidaJ1 ++;
		}

		if (generacionColores == 9)
		{
			printf("*** Jugador 2 no adivino los colores ***\n");
			config.estado = 2;
			final.puntaje1 += generacionColores;
			partidaJ1 ++;
		}
		
	}
	return &result;
}

info_color *
actualizartablerocolor_1_svc(int *argp, struct svc_req *rqstp)
{
	static info_color  result;

	
	result.generacion = color.generacion;
	strcpy(result.color1, color.color1);
	strcpy(result.color2, color.color2);
	strcpy(result.color3, color.color3);
	strcpy(result.color4, color.color4);
	strcpy(result.color5, color.color5);

	printf("*** Actualizar tablero generacion color:%d ***\n", result.generacion);
	return &result;
}

bool_t *
enviarespigas_1_svc(info_espiga *argp, struct svc_req *rqstp)
{
	static bool_t  result;

	printf("*** Enviar espigas ***\n");
	//Comprobar si las espigas enviadas son las correctas
	// 1 convertir la estructura solucion a un array
	// 2 convertir la estructura de colores a un array
	// 3 comparar los arrays
	// 4 por cada acierto de color "  N  "
	// 5 si el color esta pero no en la posicion correcta "  B  "
	// 6 si el color no esta "  X  "

	char solucionArray[5][JMAXDAT];
	char coloresArray[5][JMAXDAT];
	char solucionEspigas[5][JMAXDAT];

	strcpy(solucionArray[0], solucion.color1);
	strcpy(solucionArray[1], solucion.color2);
	strcpy(solucionArray[2], solucion.color3);
	strcpy(solucionArray[3], solucion.color4);
	strcpy(solucionArray[4], solucion.color5);

	strcpy(coloresArray[0], color.color1);
	strcpy(coloresArray[1], color.color2);
	strcpy(coloresArray[2], color.color3);
	strcpy(coloresArray[3], color.color4);
	strcpy(coloresArray[4], color.color5);

	for(int i =0; i<5; i++)
	{
		if (strcmp(solucionArray[i], coloresArray[i]) == 0)
		{
			strcpy(solucionEspigas[i], "N");
		}else
		{
			for (int j = 0; j < 5; j++)
			{
				if (strcmp(solucionArray[j], coloresArray[i]) == 0)
				{
					strcpy(solucionEspigas[j], "B");
				}				
			}		
		}	
	}
	//Si no hay coincidencias enviar X
	for (int i = 0; i < 5; i++)
	{
		if (strcmp(solucionEspigas[i], "N") != 0 && strcmp(solucionEspigas[i], "B") != 0)
		{
			strcpy(solucionEspigas[i], "X");
		}
	}

	//Verificar que las espeigas enviadas sean las correctas
	int coincidencias = 0;

	if (strcmp(solucionEspigas[0], argp->espiga1) == 0) coincidencias++;
	if (strcmp(solucionEspigas[1], argp->espiga2) == 0) coincidencias++;
	if (strcmp(solucionEspigas[2], argp->espiga3) == 0) coincidencias++;
	if (strcmp(solucionEspigas[3], argp->espiga4) == 0) coincidencias++;
	if (strcmp(solucionEspigas[4], argp->espiga5) == 0) coincidencias++;

	if (partidaJ1 == 1)
	{
		final.puntaje1 += (coincidencias == 5) ? 0 : 3;
		printf("*** Puntaje jugador 1: %d ***\n", final.puntaje1);
	}
	else
	{
		final.puntaje2 += (coincidencias == 5) ? 0 : 3;
		printf("*** Puntaje jugador 1: %d ***\n", final.puntaje1);
	}

	strcpy(espiga.espiga1, solucionEspigas[0]);
	strcpy(espiga.espiga2, solucionEspigas[1]);
	strcpy(espiga.espiga3, solucionEspigas[2]);
	strcpy(espiga.espiga4, solucionEspigas[3]);
	strcpy(espiga.espiga5, solucionEspigas[4]);

	generacionEspigas += 1;
	espiga.generacion = generacionEspigas;


	return &result;
}

info_espiga *
actualizartableroespiga_1_svc(int *argp, struct svc_req *rqstp)
{
	static info_espiga  result;

	result.generacion = espiga.generacion;
	strcpy(result.espiga1, espiga.espiga1);
	strcpy(result.espiga2, espiga.espiga2);
	strcpy(result.espiga3, espiga.espiga3);
	strcpy(result.espiga4, espiga.espiga4);
	strcpy(result.espiga5, espiga.espiga5);

	printf("*** Actualizar tablero generacion espiga:%d ***\n", result.generacion);


	return &result;
}

fin_juego *
puntuacion_1_svc(int *argp, struct svc_req *rqstp)
{
	static fin_juego  result;

	printf("\n*** Enviar puntuacion ***\n");
	final.id_partida = codigo;
	if (final.puntaje1 > final.puntaje2)
	{
		final.id_ganador = id_jugador1;
	}else
	{
		final.id_ganador = id_jugador2;
	}


	result.id_partida = final.id_partida;
	result.id_ganador = final.id_ganador;
	result.puntaje1 = final.puntaje1;
	result.puntaje2 = final.puntaje2;

	CLIENT *clnt;
	void  *result_1;
	struct datos_juego  enviarnotificacion_1_arg;
	datos_juego  *result_2;
	int  historial_1_arg;

#ifndef	DEBUG
	char *host="localhost";
	clnt = clnt_create (host, registro_juego, registro_juego_version, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */

	enviarnotificacion_1_arg.id_jugador1 = id_jugador1;
	enviarnotificacion_1_arg.id_jugador2 = id_jugador2;

	enviarnotificacion_1_arg.id_juego = codigo;

	//Guardar el id del ganador
	enviarnotificacion_1_arg.ganador = final.id_ganador;

	//Guardar la fecha del juego
	strcpy(enviarnotificacion_1_arg.fecha, "2023-10-20");

	//Enviar notificacion a los jugadores
	result_1 = enviarnotificacion_1(&enviarnotificacion_1_arg, clnt);
	if (result_1 == (void *) NULL) {
		clnt_perror (clnt, "call failed");
	}
	printf("\n***  enviar notificacion sregistro ***\n");

#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */
	return &result;
}

void *
enviarconfirmacion_1_svc(int *argp, struct svc_req *rqstp)
{
	static char * result;

	printf("\n*** Enviar confirmacion de repetir color jugador 2 ***\n");

	config.repetirColor = *argp;
	//Cambiar el estado del juego
	config.estado = 1;


	return (void *) &result;
}

int *
estadojuego_1_svc(void *argp, struct svc_req *rqstp)
{
	static int  result;

	printf("\n*** parida: %d ***\n", partidaJ1);

	//reiniciamos todo lo necesario para el siguiente juego
	if (partidaJ1 == 2)
	{
		generacionEspigas = 0;
		generacionColores = 0;
		espiga.generacion = 0;
		primeraVez = 0;
		partidaJ1 = 3;
	}

	printf("\n*** Enviar estado del juego ***\n");
	result = config.estado;

	return &result;
}


data_juego *
consulta_1_svc(int *argp, struct svc_req *rqstp)
{
	static data_juego  result;

	printf("\n*** Consultar datos del juego ***\n");

	CLIENT *clnt;
	datos_juego  *result_2;

#ifndef	DEBUG
	char *host="localhost";
	clnt = clnt_create (host, registro_juego, registro_juego_version, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */


	//Enviar notificacion a los jugadores
	result_2 = historial_1(argp, clnt);
	if (result_2 == (void *) NULL) {
		clnt_perror (clnt, "call failed");
	}
	printf("\n***  consultar notificacion sregistro ***\n");

	result.id_jugador1 = result_2->id_jugador1;
	result.id_jugador2 = result_2->id_jugador2;
	result.id_juego = result_2->id_juego;
	result.ganador = result_2->ganador;
	strcpy(result.fecha, result_2->fecha);


#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */

	

	return &result;
}
